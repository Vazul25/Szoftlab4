% Szglab4
% ===========================================================================
%
\chapter{Grafikus felület specifikációja}

\thispagestyle{fancy}

\section{A grafikus interfész}
\comment{A menürendszer, a kezelői felület grafikus képe. A grafikus felület megjelenését, a használt ikonokat, stb screenshot-szerű képekkel kell bemutatni. Az építészetben ez a homlokzati terv.}

\begin{figure}[h]
\begin{center}
%\includegraphics[width=17cm]{chapters/chapter11/example.pdf}
\caption{x}
\label{fig:Grafikus}
\end{center}
\end{figure}

\section{A grafikus rendszer architektúrája}
\comment{A felület működésének elve, a grafikus rendszer architektúrája (struktúra diagramok). A struktúra diagramokon a prototípus azon és csak azon osztályainak is szerepelnie kell, amelyekhez a grafikus felületet létrehozó osztályok kapcsolódnak.}

\subsection{A felület működési elve}
\comment{Le kell írni, hogy a grafikai megjelenésért felelős osztályok, objektumok hogyan kapcsolódnak a meglevő rendszerhez, a megjelenítés során mi volt az alapelv. Törekedni kell az MVC megvalósításra. Alapelvek lehetnek: \textbf{push} alapú: a modell értesíti a felületet, hogy változott; \textbf{pull} alapú: a felület kérdezi le a modellt, hogy változott-e; \textbf{kevert}: a kettő kombinációja.}
A grafikus felületet a java swing segítségével készítettük el. Két részből és a kezdeti menüből áll.
Az első rész magának a játéknak a megjelenítéséért felel.
 Minden, a képernyőn megjelenítendő objektumnak van egy iVisible interfésze. A Phoebe osztály ezeknek az objektumoknak a Paint függvényét hívja meg sorban kirajzolásnál, a saját paint függvényében, ami akkor hívódik ha invalidálják(repaintet hívnak) a képet.
A megjelenítés push alapú. Ha a játékban történik bármi olyan változás, ami a grafikus felületre is kihathat, akkor az aktuális függvény meghívja a Phoebe repaint metódusát, ami ennek hatására újra rajzoltatja a grafikus felületet. A újra rajzolást az alábbi függvények kérhetik: Robot: deathAnimation, move, keyPressed, Cleaner: deathAnimation, move. A kirajzolás a swing Graphics2d függvényeire épül, minden iVisible osztályhoz tartozik statikus BufferedImage változó ami paint hívására kirajzolódik az aktuális objektum x,y koordinátáin  az objektumhoz tartozó szélességi és magassági értékkel. 
A második rész: a HUD megjelenítéséért felel. Ez a frame alsó sávját foglalja el és a játékosok számára írja ki a játék aktuális információit: robotok olaj/ragacs tartalékát, az eltelt időt, továbbá a megtett körök számát. Ez a rész pull alapú, a változásokat bizonyos időközönként mintavételezi (1 mp) és megjeleníti.  
A menü a játékmód kiválasztását és  a játék indítását végzi.  


\subsection{A felület osztály-struktúrája}
\comment{Osztálydiagram. Minden új osztály, és azon régiek, akik az újakhoz közvetlenül kapcsolódnak.}

\section{A grafikus objektumok felsorolása}
\comment{Az új osztályok felsorolása. Az régi osztályok közül azoknak a felsorolása, ahol változás volt. Ezek esetén csak a változásokat kell leírni.}

\subsection{Cleaner}
\begin{itemize}
\item Ősosztályok\\
Unit
\item Attribútumok
    \begin{itemize}
        \item\# \textbf{BufferedImage} img[]: A kis robotok képeit tartalmazza, az animáció miatt többet.
    \end{itemize}
\item Metódusok
	\begin{itemize}
    	\item void \textbf{deathAnimation}(): A kis robot halálának animációja.
    	\item void \textbf{clean}(Obstacle obst): A feltakarított akadály törlése az akadályok listájából.
    	\item void \textbf{paint}(Graphics g): Kirajzolja a kis robot képét az x,y koordinátákon.
    	\item void \textbf{die}(): Egy olajat hoz létre a robot halálakor, majd meghívja a deathAnimation()-t.
	\end{itemize}
\end{itemize}


\subsection{Unit}
\begin{itemize}
\item Interfészek\\
iVisible
\item Attribútumok
	\begin{itemize}
		\item \# \textbf{Rectangle} hitbox: Az egységet a pályán reprezentáló téglalap.
	\end{itemize}
\end{itemize}

\subsection{Osztály1}
\begin{itemize}
\item Felelősség\newline
\comment{Mi az osztály felelőssége. Kb 1 bekezdés. Ha szükséges, akkor state-chart is.}
\item Ősosztályok\newline
\comment{Mely osztályokból származik (öröklési hierarchia)\newline
Legősebb osztály $\rightarrow$ Ősosztály2 $\rightarrow$ Ősosztály3...}
\item Interfészek\newline
\comment{Mely interfészeket valósítja meg.}
\item Attribútumok\newline
\comment{Milyen attribútumai vannak}
	\begin{itemize}
		\item attribútum1: attribútum jellemzése: mire való, láthatósága (UML jelöléssel), típusa
		\item attribútum2: attribútum jellemzése: mire való, láthatósága (UML jelöléssel), típusa
	\end{itemize}
\item Metódusok\newline
\comment{Milyen publikus, protected és privát  metódusokkal rendelkezik. Metódusonként precíz leírás, ha szükséges, activity diagram is  a metódusban megvalósítandó algoritmusról.}
	\begin{itemize}
		\item int foo(Osztály3 o1, Osztály4 o2): metódus leírása, láthatósága (UML jelöléssel)
		\item int bar(Osztály5 o1): metódus leírása, láthatósága (UML jelöléssel)
	\end{itemize}
\end{itemize}


\section{Kapcsolat az alkalmazói rendszerrel}
\comment{Szekvencia-diagramokon ábrázolni kell a grafikus rendszer működését. Konzisztens kell legyen az előző alfejezetekkel. Minden metódus, ami ott szerepel, fel kell tűnjön valamelyik szekvenciában. Minden metódusnak, ami szekvenciában szerepel, szereplnie kell a valamelyik osztálydiagramon.}

